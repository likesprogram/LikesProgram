#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import urllib.request

# ---------------------- 基础配置 ----------------------
UNICODE_URL = "https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt"
BASE_DIR = os.path.dirname(os.path.realpath(__file__))
HEADER_PATH = "../../../include/LikesProgram/unicode/Case.hpp"
BMP_CPP = os.path.join(BASE_DIR, "CaseBMP.cpp")
SMP_CPP = os.path.join(BASE_DIR, "CaseSMP.cpp")

# ---------------------- 下载 Unicode 数据 ----------------------
print("Downloading UnicodeData.txt ...")
with urllib.request.urlopen(UNICODE_URL) as response:
    unicode_data = response.read().decode("utf-8")

bmp_upper, bmp_lower, smp_upper, smp_lower = {}, {}, {}, {}

for line in unicode_data.splitlines():
    fields = line.strip().split(";")
    if len(fields) < 14:
        continue
    cp = int(fields[0], 16)
    upper = int(fields[12], 16) if fields[12] else None
    lower = int(fields[13], 16) if fields[13] else None

    if cp <= 0xFFFF:
        if upper is not None and upper != cp:
            bmp_upper[cp] = upper
        if lower is not None and lower != cp:
            bmp_lower[cp] = lower
    else:
        if upper is not None and upper != cp:
            smp_upper[cp] = upper
        if lower is not None and lower != cp:
            smp_lower[cp] = lower

# ---------------------- 版权声明 ----------------------
HEADER_COMMENT = """\
// Auto-generated by CreateUnicodeCaseMap.py
// Derived from UnicodeData.txt, © Unicode, Inc., under the Unicode License
// Copyright (c) 2025 龙兵寅
// This file is part of a proprietary project, do not modify manually.
// 
// UnicodeData.txt source: https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt
// To regenerate this file, run CreateUnicodeCaseMap.py with a Python environment.
"""
# ---------------------- BMP 直接数组索引 ----------------------
def write_bmp_cpp(filename, upper_map, lower_map):
    with open(filename, "w", encoding="utf-8-sig") as f:
        f.write(HEADER_COMMENT + "\n\n")
        f.write('#include "' + HEADER_PATH + '"\n\n')
        f.write("namespace LikesProgram {\n")
        f.write("    namespace Unicode {\n")
        f.write("        namespace Case {\n")
        # Upper
        f.write("            static constexpr uint16_t BMPUpperTable[65536] = {\n")
        line_elements = []
        for i in range(65536):
            line_elements.append(f"0x{upper_map.get(i,i):04X}")
            if len(line_elements) == 12:
                f.write("                " + ", ".join(line_elements) + ",\n")
                line_elements = []
        if line_elements:
            f.write("                " + ", ".join(line_elements) + "\n")
        f.write("            };\n\n")
        f.write("            uint16_t BMPToUpper(uint16_t c) { return BMPUpperTable[c]; }\n\n")

        # Lower
        f.write("            static constexpr uint16_t BMPLowerTable[65536] = {\n")
        line_elements = []
        for i in range(65536):
            line_elements.append(f"0x{lower_map.get(i,i):04X}")
            if len(line_elements) == 12:
                f.write("                " + ", ".join(line_elements) + ",\n")
                line_elements = []
        if line_elements:
            f.write("                " + ", ".join(line_elements) + "\n")
        f.write("            };\n\n")
        f.write("            uint16_t BMPToLower(uint16_t c) { return BMPLowerTable[c]; }\n")
        f.write("        }\n")
        f.write("    }\n")
        f.write("}\n")

# ---------------------- SMP 哈希索引 ----------------------
def emit_smp_table(f, name, mapping_upper, mapping_lower):
    """
    生成合并数组：
    struct SMPEntry { uint32_t code; uint32_t upper; uint32_t lower; }
    """
    # 获取所有 code 并排序
    codes = sorted(set(mapping_upper.keys()) | set(mapping_lower.keys()))
    
    f.write(f"            static constexpr struct SMPEntry {{ uint32_t code; uint32_t upper; uint32_t lower; }} {name}[] = {{\n")
    line_elements = []
    for cp in codes:
        upper = mapping_upper.get(cp, cp)
        lower = mapping_lower.get(cp, cp)
        line_elements.append(f"{{0x{cp:X}, 0x{upper:X}, 0x{lower:X}}}")
        if len(line_elements) == 6:
            f.write("                " + ", ".join(line_elements) + ",\n")
            line_elements = []
    if line_elements:
        f.write("                " + ", ".join(line_elements) + "\n")
    f.write("            };\n\n")
    return len(codes)


def write_smp_cpp(filename, mapping_upper, mapping_lower):
    """生成 SMP C++ 文件，使用合并数组 + 二分查找"""
    with open(filename, "w", encoding="utf-8-sig") as f:
        f.write(HEADER_COMMENT + "\n\n")
        f.write('#include "' + HEADER_PATH + '"\n')
        f.write('#include <cstddef>\n\n')
        f.write("namespace LikesProgram {\n")
        f.write("    namespace Unicode {\n")
        f.write("        namespace Case {\n")

        size = emit_smp_table(f, "SMPTable", mapping_upper, mapping_lower)
        f.write(f"            constexpr size_t SMP_TABLE_SIZE = {size};\n\n")

        f.write("""\
            uint32_t SMPToUpper(uint32_t c) {
                size_t left = 0, right = SMP_TABLE_SIZE;
                while (left < right) {
                    size_t mid = (left + right) / 2;
                    if (SMPTable[mid].code < c) left = mid + 1;
                    else right = mid;
                }
                if (left < SMP_TABLE_SIZE && SMPTable[left].code == c) return SMPTable[left].upper;
                return c;
            }

            uint32_t SMPToLower(uint32_t c) {
                size_t left = 0, right = SMP_TABLE_SIZE;
                while (left < right) {
                    size_t mid = (left + right) / 2;
                    if (SMPTable[mid].code < c) left = mid + 1;
                    else right = mid;
                }
                if (left < SMP_TABLE_SIZE && SMPTable[left].code == c) return SMPTable[left].lower;
                return c;
            }
""")
        f.write("        }\n")
        f.write("    }\n")
        f.write("}\n")

# ---------------------- 写出 cpp ----------------------
print("Generating BMP cpp ...")
write_bmp_cpp(BMP_CPP, bmp_upper, bmp_lower)
print("BMP cpp 生成完成:", BMP_CPP)

print("Generating SMP cpp ...")
write_smp_cpp(SMP_CPP, smp_upper, smp_lower)
print("SMP cpp 生成完成:", SMP_CPP)
